#!/usr/bin/env python

"""
odeps: Return a list of object files that the specified object file
       depends on and should be linked with. Assumes that a partner
       file path/to/foo.d exists alongside path/to/foo.o containing
       GCC/Clang's dependency output.

Usage: odeps [-n] path/to/foo.o

    -n    Don't calculate dependencies recursively:
          only print deps from first object file
"""

import os
import re
import sys

ROOT = os.path.join(os.path.dirname(__file__), '..')
BUILD = os.path.join(ROOT, 'build')
SRC = os.path.join(ROOT, 'src')

SRC_FROM_BUILD = os.path.relpath(SRC, BUILD)

def dep_to_ofile(filename):
    filename = re.sub(r'^%s/' % SRC_FROM_BUILD, '', filename)
    if filename[-4:] == '.cpp':
        return None
    elif filename[-2:] == '.h':
        return filename[:-2] + '.o'

def parse_dfile(filename):
    # Remove escaped newlines
    contents = open(filename).read().replace('\\\n', '')
    # Remove target name
    contents = re.sub(r'[^:]+:', '', contents)
    o_files = map(dep_to_ofile, contents.split())
    return filter(None, o_files)

def odeps(filename, recurse=True):
    if not filename[-2:] == '.o':
        raise Exception("That's not an object file")

    obj_from_build = os.path.relpath(filename, BUILD)

    if '..' in obj_from_build:
        raise Exception("Can't give deps for object files outside of BUILD dir")

    prepend = filename[:-len(obj_from_build)]

    deps = set()
    deps.update(prepend + x for x in parse_dfile(filename[:-2] + '.d'))
    deps.discard(filename)

    if recurse:
        for d in deps.copy():
            deps.update(odeps(d))

    return deps

def main(filename, recurse=True):
    for d in odeps(filename, recurse):
        print d

if __name__ == '__main__':
    if sys.argv[1] == '-n':
        main(sys.argv[2], False)
    else:
        main(sys.argv[1])
